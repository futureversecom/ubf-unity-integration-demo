// Copyright (c) 2025, Futureverse Corporation Limited. All rights reserved.
// <auto-generated>
// This code is generated by csbindgen.
// DON'T CHANGE THIS DIRECTLY.
// </auto-generated>
#pragma warning disable CS8500
#pragma warning disable CS8981
using System;
using System.Runtime.InteropServices;


namespace Futureverse.UBF.Runtime.Native.FFI
{
    internal static unsafe partial class Calls
    {
#if (UNITY_WEBGL || UNITY_IOS) && !UNITY_EDITOR
        const string __DllName = "__Internal";
#else
        const string __DllName = "ubf_interpreter";
#endif
        



        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        public delegate void graph_load_on_log_delegate(int arg1, byte* arg2, int arg3);

        [DllImport(__DllName, EntryPoint = "graph_load", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern GraphInstance* graph_load(NodeRegistry* registry, ushort* json, int json_len, graph_load_on_log_delegate on_log);

        [DllImport(__DllName, EntryPoint = "graph_version", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        [return: MarshalAs(UnmanagedType.U1)]
        public static extern bool graph_version(GraphInstance* graph, ushort** out_ptr, nuint* out_len);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        public delegate bool graph_iter_inputs_iterator_delegate(nint arg1, byte* arg2, int arg3, byte* arg4, int arg5, Dynamic* arg6);

        [DllImport(__DllName, EntryPoint = "graph_iter_inputs", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern void graph_iter_inputs(GraphInstance* graph, nint context, graph_iter_inputs_iterator_delegate iterator);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        public delegate bool graph_iter_outputs_iterator_delegate(nint arg1, byte* arg2, int arg3, byte* arg4, int arg5, Dynamic* arg6);

        [DllImport(__DllName, EntryPoint = "graph_iter_outputs", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern void graph_iter_outputs(GraphInstance* graph, nint context, graph_iter_outputs_iterator_delegate iterator);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        public delegate void graph_execute_on_graph_complete_delegate(Dynamic* arg1);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        public delegate void graph_execute_on_node_complete_delegate(byte* arg1, int arg2, uint arg3, Dynamic* arg4);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        public delegate void graph_execute_on_node_start_delegate(byte* arg1, int arg2, uint arg3, Dynamic* arg4);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        public delegate void graph_execute_on_log_delegate(int arg1, byte* arg2, int arg3, Dynamic* arg4);

        /// <summary>Execute the UBF Graph.</summary>
        [DllImport(__DllName, EntryPoint = "graph_execute", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern ArcExecutionContext* graph_execute(GraphInstance* graph, Dynamic* inputs, Dynamic* context_data, ushort* graph_label, int graph_label_len, graph_execute_on_graph_complete_delegate on_graph_complete, graph_execute_on_node_complete_delegate on_node_complete, graph_execute_on_node_start_delegate on_node_start, graph_execute_on_log_delegate on_log);

        /// <summary>Free graph</summary>
        [DllImport(__DllName, EntryPoint = "graph_release", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern void graph_release(GraphInstance* graph);

        /// <summary>Retain graph reference</summary>
        [DllImport(__DllName, EntryPoint = "graph_retain", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern GraphInstance* graph_retain(GraphInstance* graph);

        [DllImport(__DllName, EntryPoint = "ctx_release", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern void ctx_release(ArcExecutionContext* execution_context);

        /// <summary>Retain reference</summary>
        [DllImport(__DllName, EntryPoint = "ctx_retain", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern ArcExecutionContext* ctx_retain(ArcExecutionContext* execution_context);

        [DllImport(__DllName, EntryPoint = "ctx_trigger_node", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern byte ctx_trigger_node(ArcExecutionContext* execution_context, ushort* source_node_id_str, int source_node_id_len, ushort* source_port_key_str, int source_port_key_len, uint scope, uint* child_scope);

        [DllImport(__DllName, EntryPoint = "ctx_complete_node", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        [return: MarshalAs(UnmanagedType.U1)]
        public static extern bool ctx_complete_node(ArcExecutionContext* execution_context, uint scope);

        [DllImport(__DllName, EntryPoint = "ctx_read_output", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        [return: MarshalAs(UnmanagedType.U1)]
        public static extern bool ctx_read_output(ArcExecutionContext* execution_context, ushort* binding_id, int binding_id_len, Dynamic** @out);

        [DllImport(__DllName, EntryPoint = "ctx_read_input", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        [return: MarshalAs(UnmanagedType.U1)]
        public static extern bool ctx_read_input(ArcExecutionContext* execution_context, ushort* node_id, int node_id_len, ushort* port_key, int port_key_len, uint scope, Dynamic** @out);

        [DllImport(__DllName, EntryPoint = "ctx_get_context_data", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern Dynamic* ctx_get_context_data(ArcExecutionContext* execution_context);

        [DllImport(__DllName, EntryPoint = "ctx_get_dynamic_data_entry", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        [return: MarshalAs(UnmanagedType.U1)]
        public static extern bool ctx_get_dynamic_data_entry(ArcExecutionContext* execution_context, ushort* key, int key_len, Dynamic** @out);

        [DllImport(__DllName, EntryPoint = "ctx_set_dynamic_data_entry", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        [return: MarshalAs(UnmanagedType.U1)]
        public static extern bool ctx_set_dynamic_data_entry(ArcExecutionContext* execution_context, ushort* key, int key_len, Dynamic* value);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        public delegate bool ctx_get_declared_node_inputs_iterator_delegate(nint arg1, byte* arg2, int arg3);

        [DllImport(__DllName, EntryPoint = "ctx_get_declared_node_inputs", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        [return: MarshalAs(UnmanagedType.U1)]
        public static extern bool ctx_get_declared_node_inputs(ArcExecutionContext* execution_context, ushort* node_id, int node_id_len, nint context, ctx_get_declared_node_inputs_iterator_delegate iterator);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        public delegate bool ctx_get_graph_outputs_iterator_delegate(nint arg1, byte* arg2, int arg3, Dynamic* arg4);

        [DllImport(__DllName, EntryPoint = "ctx_get_graph_outputs", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        [return: MarshalAs(UnmanagedType.U1)]
        public static extern bool ctx_get_graph_outputs(ArcExecutionContext* execution_context, nint context, ctx_get_graph_outputs_iterator_delegate iterator);

        /// <summary>Write a value to the current execution context.</summary>
        [DllImport(__DllName, EntryPoint = "ctx_write_output", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern void ctx_write_output(ArcExecutionContext* execution_context, ushort* node_id, int node_id_len, ushort* port_key, int port_key_len, Dynamic* value);

        [DllImport(__DllName, EntryPoint = "dynamic_release", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern void dynamic_release(Dynamic* value);

        /// <summary>Retain reference</summary>
        [DllImport(__DllName, EntryPoint = "dynamic_retain", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern Dynamic* dynamic_retain(Dynamic* value);

        [DllImport(__DllName, EntryPoint = "dynamic_new_primitive", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern Dynamic* dynamic_new_primitive(DynamicType typ, int value, float value_float);

        [DllImport(__DllName, EntryPoint = "dynamic_new_string", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern Dynamic* dynamic_new_string(ushort* value, int value_len);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        public delegate void dynamic_new_foreign_drop_delegate(nint arg1);

        [DllImport(__DllName, EntryPoint = "dynamic_new_foreign", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern Dynamic* dynamic_new_foreign(nint ptr, dynamic_new_foreign_drop_delegate drop);

        [DllImport(__DllName, EntryPoint = "dynamic_new_dictionary", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern Dynamic* dynamic_new_dictionary();

        [DllImport(__DllName, EntryPoint = "dynamic_new_array", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern Dynamic* dynamic_new_array();

        /// <summary>Push value onto array</summary>
        [DllImport(__DllName, EntryPoint = "dynamic_array_push", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        [return: MarshalAs(UnmanagedType.U1)]
        public static extern bool dynamic_array_push(Dynamic* array, Dynamic* value);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        public delegate bool dynamic_array_iter_iterator_delegate(nint arg1, Dynamic* arg2);

        [DllImport(__DllName, EntryPoint = "dynamic_array_iter", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern void dynamic_array_iter(Dynamic* array, nint context, dynamic_array_iter_iterator_delegate iterator);

        /// <summary>Return the string value of a dynamic value. Note that we allocate as much memory as needed to store the string and the caller is responsible for freeing it.</summary>
        [DllImport(__DllName, EntryPoint = "dynamic_as_string", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        [return: MarshalAs(UnmanagedType.U1)]
        public static extern bool dynamic_as_string(Dynamic* value, void** @out, ushort** out_ptr, nuint* out_len);

        [DllImport(__DllName, EntryPoint = "box_release", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern void box_release(void* ptr);

        [DllImport(__DllName, EntryPoint = "dynamic_to_string", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        [return: MarshalAs(UnmanagedType.U1)]
        public static extern bool dynamic_to_string(Dynamic* value, void** @out, ushort** out_ptr, nuint* out_len);

        [DllImport(__DllName, EntryPoint = "dynamic_extract", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern void dynamic_extract(Dynamic* value, DynamicType* out_type, int* out_int, float* out_float, nint* out_ptr);

        [DllImport(__DllName, EntryPoint = "dynamic_dictionary_get", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        [return: MarshalAs(UnmanagedType.U1)]
        public static extern bool dynamic_dictionary_get(Dynamic* dictionary, ushort* key, int key_len, Dynamic** @out);

        [DllImport(__DllName, EntryPoint = "dynamic_dictionary_set", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        [return: MarshalAs(UnmanagedType.U1)]
        public static extern bool dynamic_dictionary_set(Dynamic* dictionary, ushort* key, int key_len, Dynamic* value);

        [DllImport(__DllName, EntryPoint = "registry_new", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern NodeRegistry* registry_new();

        /// <summary>Free registry</summary>
        [DllImport(__DllName, EntryPoint = "registry_release", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern void registry_release(NodeRegistry* registry);

        /// <summary>Retain reference</summary>
        [DllImport(__DllName, EntryPoint = "registry_retain", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern NodeRegistry* registry_retain(NodeRegistry* registry);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        public delegate void registry_register_node_execute_cb_delegate(nint arg1, byte* arg2, uint arg3, ArcExecutionContext* arg4);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        public delegate void registry_register_node__release_cb_delegate(nint arg1);

        /// <summary>Register a custom, external node.</summary>
        [DllImport(__DllName, EntryPoint = "registry_register_node", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern void registry_register_node(NodeRegistry* registry, ushort* name, int name_len, nint this_ptr, registry_register_node_execute_cb_delegate execute_cb, registry_register_node__release_cb_delegate _release_cb);

        /// <summary>This function is called when the plugin is loaded.  note: For reasons the C symbol is not exported after building; hence the wrapper function to forward the call.</summary>
        [DllImport(__DllName, EntryPoint = "UnityPluginLoad", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern void UnityPluginLoad(void* ptr);

        /// <summary>This function is called when the plugin is unloaded.  note: For reasons the C symbol is not exported after building; hence the wrapper function to forward the call.</summary>
        [DllImport(__DllName, EntryPoint = "UnityPluginUnload", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern void UnityPluginUnload();


    }

    [StructLayout(LayoutKind.Sequential)]
    internal unsafe partial struct ArcExecutionContext
    {
    }

    [StructLayout(LayoutKind.Sequential)]
    internal unsafe partial struct NodeRegistry
    {
    }

    [StructLayout(LayoutKind.Sequential)]
    internal unsafe partial struct GraphInstance
    {
    }


    internal enum DynamicType : uint
    {
        Unknown = 0,
        Bool = 1,
        Int = 2,
        Float = 3,
        String = 4,
        Array = 5,
        Dictionary = 6,
        Foreign = 7,
    }

    internal enum Dynamic
    {
        NullValue,
        BoolValue,
        IntValue,
        FloatValue,
        StringValue,
        ArrayValue,
        Dictionary,
        ForeignValue,
    }


}
